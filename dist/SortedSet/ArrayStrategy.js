// Generated by CoffeeScript 2.5.1
(function() {
  var ArrayStrategy, Iterator, binarySearchForIndex, enums;

  enums = require('../enums');

  Iterator = class Iterator {
    constructor(priv, index1) {
      this.priv = priv;
      this.index = index1;
      this.data = this.priv.data;
    }

    hasNext() {
      return this.index < this.data.length;
    }

    hasPrevious() {
      return this.index > 0;
    }

    value() {
      if (this.index < this.data.length) {
        return this.data[this.index];
      } else {
        return null;
      }
    }

    setValue(value) {
      if (!this.priv.options.allowSetValue) {
        throw 'Must set options.allowSetValue';
      }
      if (!this.hasNext()) {
        throw 'Cannot set value at end of set';
      }
      return this.data[this.index] = value;
    }

    next() {
      if (this.index >= this.data.length) {
        return null;
      } else {
        return new Iterator(this.priv, this.index + 1);
      }
    }

    previous() {
      if (this.index <= 0) {
        return null;
      } else {
        return new Iterator(this.priv, this.index - 1);
      }
    }

  };

  binarySearchForIndex = function(array, value, comparator) {
    var high, low, mid;
    low = 0;
    high = array.length;
    while (low < high) {
      mid = (low + high) >>> 1;
      if (comparator(array[mid], value) < 0) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  };

  ArrayStrategy = class ArrayStrategy {
    constructor(options) {
      this.options = options;
      this.insertBehavior = this.options.insertBehavior;
      this.comparator = this.options.comparator;
      this.data = [];
    }

    toArray() {
      return this.data;
    }

    insert(value) {
      var index;
      index = binarySearchForIndex(this.data, value, this.comparator);
      if (value !== void 0 && this.data[index] !== void 0 && this.comparator(this.data[index], value) === 0) {
        switch (this.insertBehavior) {
          case enums.insertBehaviors.throw:
            throw 'Value already in set';
          case enums.insertBehaviors.replace:
            this.data.splice(index, 1, value);
            return true;
          case enums.insertBehaviors.ignore:
            return false;
          default:
            throw 'Unsupported insert behavior #{@insertBehavior}';
        }
      } else {
        this.data.splice(index, 0, value);
        return true;
      }
    }

    remove(value) {
      var index;
      index = binarySearchForIndex(this.data, value, this.comparator);
      if (this.data[index] !== value) {
        throw 'Value not in set';
      }
      return this.data.splice(index, 1);
    }

    clear() {
      return this.data.length = 0;
    }

    contains(value) {
      var index;
      index = binarySearchForIndex(this.data, value, this.comparator);
      return this.index !== this.data.length && this.data[index] === value;
    }

    forEachImpl(callback, sortedSet, thisArg) {
      var i, index, len, ref, value;
      ref = this.data;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        value = ref[index];
        callback.call(thisArg, value, index, sortedSet);
      }
      return void 0;
    }

    findIterator(value) {
      var index;
      index = binarySearchForIndex(this.data, value, this.comparator);
      return new Iterator(this, index);
    }

    beginIterator() {
      return new Iterator(this, 0);
    }

    endIterator() {
      return new Iterator(this, this.data.length);
    }

  };

  module.exports = ArrayStrategy;

}).call(this);
