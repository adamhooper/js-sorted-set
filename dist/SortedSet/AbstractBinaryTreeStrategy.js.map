{
  "version": 3,
  "file": "AbstractBinaryTreeStrategy.js",
  "sourceRoot": "../..",
  "sources": [
    "src/SortedSet/AbstractBinaryTreeStrategy.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;AAAA,MAAA,kBAAA,EAAA,kBAAA,EAAA;;EAAA,kBAAA,GAAqB,OAAA,CAAQ,sBAAR;;EAErB,kBAAA,GAAqB,QAAA,CAAC,IAAD,EAAO,QAAP,CAAA;IACnB,IAAG,IAAA,KAAU,IAAb;MACE,kBAAA,CAAmB,IAAI,CAAC,IAAxB,EAA8B,QAA9B;MACA,QAAA,CAAS,IAAI,CAAC,KAAd;MACA,kBAAA,CAAmB,IAAI,CAAC,KAAxB,EAA+B,QAA/B,EAHF;;WAIA;EALmB,EAFrB;;;;EAWM,qBAAN,MAAA,mBAAA;IACE,OAAS,CAAA,CAAA;AACX,UAAA;MAAI,GAAA,GAAM;MACN,kBAAA,CAAmB,IAAC,CAAA,IAApB,EAA0B,QAAA,CAAC,KAAD,CAAA;eAAW,GAAG,CAAC,IAAJ,CAAS,KAAT;MAAX,CAA1B;aACA;IAHO;;IAKT,KAAO,CAAA,CAAA;aACL,IAAC,CAAA,IAAD,GAAQ;IADH;;IAGP,WAAa,CAAC,QAAD,EAAW,SAAX,EAAsB,OAAtB,CAAA;AACf,UAAA;MAAI,CAAA,GAAI;MACJ,kBAAA,CAAmB,IAAC,CAAA,IAApB,EAA0B,QAAA,CAAC,KAAD,CAAA;QACxB,QAAQ,CAAC,IAAT,CAAc,OAAd,EAAuB,KAAvB,EAA8B,CAA9B,EAAiC,SAAjC;eACA,CAAA,IAAK;MAFmB,CAA1B;aAGA;IALW;;IAOb,QAAU,CAAC,KAAD,CAAA;AACZ,UAAA,GAAA,EAAA,UAAA,EAAA;MAAI,UAAA,GAAa,IAAC,CAAA;MAEd,IAAA,GAAO,IAAC,CAAA;AACR,aAAM,IAAA,KAAU,IAAhB;QACE,GAAA,GAAM,UAAA,CAAW,KAAX,EAAkB,IAAI,CAAC,KAAvB;QACN,IAAG,GAAA,KAAO,CAAV;AACE,gBADF;SAAA,MAEK,IAAG,GAAA,GAAM,CAAT;UACH,IAAA,GAAO,IAAI,CAAC,KADT;SAAA,MAAA;UAGH,IAAA,GAAO,IAAI,CAAC,MAHT;;MAJP;aASA,IAAA,KAAU,IAAV,IAAkB,IAAI,CAAC,KAAL,KAAc;IAbxB;;IAeV,YAAc,CAAC,KAAD,CAAA;aAAW,kBAAkB,CAAC,IAAnB,CAAwB,IAAxB,EAA8B,KAA9B,EAAqC,IAAC,CAAA,UAAtC;IAAX;;IACd,aAAe,CAAA,CAAA;aAAG,kBAAkB,CAAC,IAAnB,CAAwB,IAAxB;IAAH;;IACf,WAAa,CAAA,CAAA;aAAG,kBAAkB,CAAC,KAAnB,CAAyB,IAAzB;IAAH;;EAjCf;;EAmCA,MAAM,CAAC,OAAP,GAAiB;AA9CjB",
  "sourcesContent": [
    "BinaryTreeIterator = require('./BinaryTreeIterator')\n\nbinaryTreeTraverse = (node, callback) ->\n  if node isnt null\n    binaryTreeTraverse(node.left, callback)\n    callback(node.value)\n    binaryTreeTraverse(node.right, callback)\n  undefined\n\n# An AbstractBinaryTree has a @root. @root is null or an object with\n# `.left`, `.right` and `.value` properties.\nclass AbstractBinaryTree\n  toArray: ->\n    ret = []\n    binaryTreeTraverse(@root, (value) -> ret.push(value))\n    ret\n\n  clear: ->\n    @root = null\n\n  forEachImpl: (callback, sortedSet, thisArg) ->\n    i = 0\n    binaryTreeTraverse @root, (value) ->\n      callback.call(thisArg, value, i, sortedSet)\n      i += 1\n    undefined\n\n  contains: (value) ->\n    comparator = @comparator\n\n    node = @root\n    while node isnt null\n      cmp = comparator(value, node.value)\n      if cmp == 0\n        break\n      else if cmp < 0\n        node = node.left\n      else\n        node = node.right\n\n    node isnt null && node.value == value\n\n  findIterator: (value) -> BinaryTreeIterator.find(this, value, @comparator)\n  beginIterator: -> BinaryTreeIterator.left(this)\n  endIterator: -> BinaryTreeIterator.right(this)\n\nmodule.exports = AbstractBinaryTree\n"
  ]
}