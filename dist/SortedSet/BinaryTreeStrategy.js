// Generated by CoffeeScript 2.5.1
(function() {
  var AbstractBinaryTreeStrategy, BinaryTreeStrategy, Node, binaryTreeDelete, enums, nodeAllTheWay;

  enums = require('../enums');

  AbstractBinaryTreeStrategy = require('./AbstractBinaryTreeStrategy');

  Node = class Node {
    constructor(value1) {
      this.value = value1;
      this.left = null;
      this.right = null;
    }

  };

  nodeAllTheWay = function(node, leftOrRight) {
    while (node[leftOrRight] !== null) {
      node = node[leftOrRight];
    }
    return node;
  };

  // Returns the subtree, minus value
  binaryTreeDelete = function(node, value, comparator) {
    var cmp, nextNode;
    if (node === null) {
      throw 'Value not in set';
    }
    cmp = comparator(value, node.value);
    if (cmp < 0) {
      node.left = binaryTreeDelete(node.left, value, comparator);
    } else if (cmp > 0) {
      node.right = binaryTreeDelete(node.right, value, comparator); // This is the value we want to remove
    } else {
      if (node.left === null && node.right === null) {
        node = null;
      } else if (node.right === null) {
        node = node.left;
      } else if (node.left === null) {
        node = node.right;
      } else {
        nextNode = nodeAllTheWay(node.right, 'left');
        node.value = nextNode.value;
        node.right = binaryTreeDelete(node.right, nextNode.value, comparator);
      }
    }
    return node;
  };

  BinaryTreeStrategy = class BinaryTreeStrategy extends AbstractBinaryTreeStrategy {
    constructor(options) {
      super();
      this.options = options;
      this.comparator = this.options.comparator;
      this.insertBehavior = this.options.insertBehavior;
      this.root = null;
    }

    insert(value) {
      var cmp, compare, leftOrRight, parent;
      compare = this.comparator;
      if (this.root != null) {
        parent = this.root;
        while (true) {
          cmp = compare(value, parent.value);
          if (cmp === 0) {
            switch (this.insertBehavior) {
              case enums.insertBehaviors.throw:
                throw 'Value already in set';
              case enums.insertBehaviors.replace:
                parent.value = value;
                return true;
              case enums.insertBehaviors.ignore:
                return false;
              default:
                throw 'Unsupported insert behavior #{@insertBehavior}';
            }
          } else {
            leftOrRight = cmp < 0 ? 'left' : 'right';
            if (parent[leftOrRight] === null) {
              break;
            }
            parent = parent[leftOrRight];
          }
        }
        parent[leftOrRight] = new Node(value);
        return true;
      } else {
        this.root = new Node(value);
        return true;
      }
    }

    remove(value) {
      return this.root = binaryTreeDelete(this.root, value, this.comparator);
    }

  };

  module.exports = BinaryTreeStrategy;

}).call(this);
