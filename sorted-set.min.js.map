{"version":3,"file":"sorted-set.min.js","sources":["src/SortedSet/ArrayStrategy.js","src/SortedSet/BinaryTreeIterator.js","src/SortedSet/AbstractBinaryTreeStrategy.js","src/SortedSet/BinaryTreeStrategy.js","src/SortedSet/RedBlackTreeStrategy.js","src/SortedSet/InsertConflictResolvers.js","src/SortedSet.js","src/SortedSet/AbstractSortedSet.js"],"sourcesContent":["\nclass Iterator {\n  constructor(priv, index1) {\n    this.priv = priv;\n    this.index = index1;\n    this.data = this.priv.data;\n  }\n\n  hasNext() {\n    return this.index < this.data.length;\n  }\n\n  hasPrevious() {\n    return this.index > 0;\n  }\n\n  value() {\n    if (this.index < this.data.length) {\n      return this.data[this.index];\n    } else {\n      return null;\n    }\n  }\n\n  setValue(value) {\n    if (!this.priv.options.allowSetValue) {\n      throw 'Must set options.allowSetValue';\n    }\n    if (!this.hasNext()) {\n      throw 'Cannot set value at end of set';\n    }\n    return this.data[this.index] = value;\n  }\n\n  next() {\n    if (this.index >= this.data.length) {\n      return null;\n    } else {\n      return new Iterator(this.priv, this.index + 1);\n    }\n  }\n\n  previous() {\n    if (this.index <= 0) {\n      return null;\n    } else {\n      return new Iterator(this.priv, this.index - 1);\n    }\n  }\n\n};\n\nconst binarySearchForIndex = (array, value, comparator) => {\n  var high, low, mid;\n  low = 0;\n  high = array.length;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(array[mid], value) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\n\nclass ArrayStrategy {\n  constructor(options) {\n    this.options = options;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.comparator = this.options.comparator;\n    this.data = [];\n  }\n\n  toArray() {\n    return this.data;\n  }\n\n  insert(value) {\n    var index;\n    index = binarySearchForIndex(this.data, value, this.comparator);\n    if (this.data[index] !== void 0 && this.comparator(this.data[index], value) === 0) {\n      return this.data.splice(index, 1, this.onInsertConflict(this.data[index], value));\n    } else {\n      return this.data.splice(index, 0, value);\n    }\n  }\n\n  remove(value) {\n    var index;\n    index = binarySearchForIndex(this.data, value, this.comparator);\n    if (this.data[index] !== value) {\n      throw 'Value not in set';\n    }\n    return this.data.splice(index, 1);\n  }\n\n  clear() {\n    return this.data.length = 0;\n  }\n\n  contains(value) {\n    var index;\n    index = binarySearchForIndex(this.data, value, this.comparator);\n    return this.index !== this.data.length && this.data[index] === value;\n  }\n\n  forEachImpl(callback, sortedSet, thisArg) {\n    var i, index, len, ref, value;\n    ref = this.data;\n    for (index = i = 0, len = ref.length; i < len; index = ++i) {\n      value = ref[index];\n      callback.call(thisArg, value, index, sortedSet);\n    }\n    return void 0;\n  }\n\n  findIterator(value) {\n    var index;\n    index = binarySearchForIndex(this.data, value, this.comparator);\n    return new Iterator(this, index);\n  }\n\n  beginIterator() {\n    return new Iterator(this, 0);\n  }\n\n  endIterator() {\n    return new Iterator(this, this.data.length);\n  }\n\n};\n\nexport default ArrayStrategy;\n","\nconst descendAllTheWay = (leftOrRight, node) => {\n  var parent;\n  // Assumes node._iteratorParentNode is set\n  while (node[leftOrRight] !== null) {\n    parent = node;\n    node = node[leftOrRight];\n    node._iteratorParentNode = parent;\n  }\n  return node;\n};\n\nconst moveCursor = (leftOrRight, node) => {\n  var parent, rightOrLeft;\n  if (node[leftOrRight] !== null) {\n    parent = node;\n    node = node[leftOrRight];\n    node._iteratorParentNode = parent;\n    rightOrLeft = leftOrRight === 'left' ? 'right' : 'left';\n    node = descendAllTheWay(rightOrLeft, node);\n  } else {\n    while ((parent = node._iteratorParentNode) !== null && parent[leftOrRight] === node) {\n      node = parent;\n    }\n    node = parent; // either null or the correct-direction parent\n  }\n  return node;\n};\n\n// The BinaryTreeIterator actually writes to the tree: it maintains a\n// \"_iteratorParentNode\" variable on each node. Please ignore this.\nclass BinaryTreeIterator {\n  constructor(tree1, node1) {\n    this.tree = tree1;\n    this.node = node1;\n  }\n\n  next() {\n    var node;\n    if (this.node === null) {\n      return null;\n    } else {\n      node = moveCursor('right', this.node);\n      return new BinaryTreeIterator(this.tree, node);\n    }\n  }\n\n  previous() {\n    var node;\n    if (this.node === null) {\n      if (this.tree.root === null) {\n        return null;\n      } else {\n        this.tree.root._iteratorParentNode = null;\n        node = descendAllTheWay('right', this.tree.root);\n        return new BinaryTreeIterator(this.tree, node);\n      }\n    } else {\n      node = moveCursor('left', this.node);\n      if (node === null) {\n        return null;\n      } else {\n        return new BinaryTreeIterator(this.tree, node);\n      }\n    }\n  }\n\n  hasNext() {\n    return this.node !== null;\n  }\n\n  hasPrevious() {\n    return this.previous() !== null;\n  }\n\n  value() {\n    if (this.node === null) {\n      return null;\n    } else {\n      return this.node.value;\n    }\n  }\n\n  setValue(value) {\n    if (!this.tree.options.allowSetValue) {\n      throw 'Must set options.allowSetValue';\n    }\n    if (!this.hasNext()) {\n      throw 'Cannot set value at end of set';\n    }\n    return this.node.value = value;\n  }\n\n};\n\nBinaryTreeIterator.find = function(tree, value, comparator) {\n  var cmp, nextNode, node, root;\n  root = tree.root;\n  if (root != null) {\n    root._iteratorParentNode = null;\n  }\n  node = root;\n  nextNode = null; // For finding an in-between node\n  while (node !== null) {\n    cmp = comparator(value, node.value);\n    if (cmp === 0) {\n      break;\n    } else if (cmp < 0) {\n      if (node.left === null) {\n        break;\n      }\n      nextNode = node; // If we descend all right after this until there are\n      // no more right nodes, we want to return an\n      // \"in-between\" iterator ... pointing here.\n      node.left._iteratorParentNode = node;\n      node = node.left;\n    } else {\n      if (node.right !== null) {\n        node.right._iteratorParentNode = node;\n        node = node.right;\n      } else {\n        node = nextNode;\n        break;\n      }\n    }\n  }\n  return new BinaryTreeIterator(tree, node);\n};\n\nBinaryTreeIterator.left = (tree) => {\n  var node;\n  if (tree.root === null) {\n    return new BinaryTreeIterator(tree, null);\n  } else {\n    tree.root._iteratorParentNode = null;\n    node = descendAllTheWay('left', tree.root);\n    return new BinaryTreeIterator(tree, node);\n  }\n};\n\nBinaryTreeIterator.right = (tree) => {\n  return new BinaryTreeIterator(tree, null);\n};\n\nexport default BinaryTreeIterator;\n\n","\nimport BinaryTreeIterator from './BinaryTreeIterator';\n\nconst binaryTreeTraverse = (node, callback) => {\n  if (node !== null) {\n    binaryTreeTraverse(node.left, callback);\n    callback(node.value);\n    binaryTreeTraverse(node.right, callback);\n  }\n  return void 0;\n};\n\n// An AbstractBinaryTree has a @root. @root is null or an object with\n// `.left`, `.right` and `.value` properties.\nclass AbstractBinaryTree {\n  toArray() {\n    var ret;\n    ret = [];\n    binaryTreeTraverse(this.root, function(value) {\n      return ret.push(value);\n    });\n    return ret;\n  }\n\n  clear() {\n    return this.root = null;\n  }\n\n  forEachImpl(callback, sortedSet, thisArg) {\n    var i;\n    i = 0;\n    binaryTreeTraverse(this.root, function(value) {\n      callback.call(thisArg, value, i, sortedSet);\n      return i += 1;\n    });\n    return void 0;\n  }\n\n  contains(value) {\n    var cmp, comparator, node;\n    comparator = this.comparator;\n    node = this.root;\n    while (node !== null) {\n      cmp = comparator(value, node.value);\n      if (cmp === 0) {\n        break;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n    return node !== null && node.value === value;\n  }\n\n  findIterator(value) {\n    return BinaryTreeIterator.find(this, value, this.comparator);\n  }\n\n  beginIterator() {\n    return BinaryTreeIterator.left(this);\n  }\n\n  endIterator() {\n    return BinaryTreeIterator.right(this);\n  }\n\n};\n\nexport default AbstractBinaryTree;\n\n","  \nimport AbstractBinaryTreeStrategy from './AbstractBinaryTreeStrategy';\n\nclass Node {\n  constructor(value1) {\n    this.value = value1;\n    this.left = null;\n    this.right = null;\n  }\n\n};\n\nconst nodeAllTheWay = (node, leftOrRight) => {\n  while (node[leftOrRight] !== null) {\n    node = node[leftOrRight];\n  }\n  return node;\n};\n\n// Returns the subtree, minus value\nconst binaryTreeDelete = (node, value, comparator) => {\n  var cmp, nextNode;\n  if (node === null) {\n    throw 'Value not in set';\n  }\n  cmp = comparator(value, node.value);\n  if (cmp < 0) {\n    node.left = binaryTreeDelete(node.left, value, comparator);\n  } else if (cmp > 0) {\n    node.right = binaryTreeDelete(node.right, value, comparator); // This is the value we want to remove\n  } else {\n    if (node.left === null && node.right === null) {\n      node = null;\n    } else if (node.right === null) {\n      node = node.left;\n    } else if (node.left === null) {\n      node = node.right;\n    } else {\n      nextNode = nodeAllTheWay(node.right, 'left');\n      node.value = nextNode.value;\n      node.right = binaryTreeDelete(node.right, nextNode.value, comparator);\n    }\n  }\n  return node;\n};\n\nclass BinaryTreeStrategy extends AbstractBinaryTreeStrategy {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.root = null;\n  }\n\n  insert(value) {\n    var cmp, compare, leftOrRight, parent;\n    compare = this.comparator;\n    if (this.root != null) {\n      parent = this.root;\n      while (true) {\n        cmp = compare(value, parent.value);\n        if (cmp === 0) {\n          parent.value = this.onInsertConflict(parent.value, value);\n          return;\n        } else {\n          leftOrRight = cmp < 0 ? 'left' : 'right';\n          if (parent[leftOrRight] === null) {\n            break;\n          }\n          parent = parent[leftOrRight];\n        }\n      }\n      return parent[leftOrRight] = new Node(value);\n    } else {\n      return this.root = new Node(value);\n    }\n  }\n\n  remove(value) {\n    return this.root = binaryTreeDelete(this.root, value, this.comparator);\n  }\n\n};\n\nexport default BinaryTreeStrategy;\n","\nimport AbstractBinaryTreeStrategy from './AbstractBinaryTreeStrategy';\n\n// An implementation of Left-Leaning Red-Black trees.\n\n// It's copied from http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf.\n// It's practically a copy-paste job, minus the semicolons. missing bits were\n// filled in with hints from\n// http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n\n// Here are some differences:\n// * This isn't a map structure: it's just a tree. There are no keys: the\n//   comparator applies to the values.\n// * We use the passed comparator.\nclass Node {\n  constructor(value1) {\n    this.value = value1;\n    this.left = null;\n    this.right = null;\n    this.isRed = true; // null nodes -- leaves -- are black\n  }\n\n};\n\nconst rotateLeft = (h) => {\n  var x;\n  x = h.right;\n  h.right = x.left;\n  x.left = h;\n  x.isRed = h.isRed;\n  h.isRed = true;\n  return x;\n};\n\nconst rotateRight = (h) => {\n  var x;\n  x = h.left;\n  h.left = x.right;\n  x.right = h;\n  x.isRed = h.isRed;\n  h.isRed = true;\n  return x;\n};\n\nconst colorFlip = (h) => {\n  h.isRed = !h.isRed;\n  h.left.isRed = !h.left.isRed;\n  h.right.isRed = !h.right.isRed;\n  return void 0;\n};\n\nconst moveRedLeft = (h) => {\n  //throw 'Preconditions failed' if !(!h.left.isRed && !h.left.left?.isRed)\n  colorFlip(h);\n  if (h.right !== null && h.right.left !== null && h.right.left.isRed) {\n    h.right = rotateRight(h.right);\n    h = rotateLeft(h);\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst moveRedRight = (h) => {\n  //throw 'Preconditions failed' if !(!h.right.isRed && !h.right.left?.isRed)\n  colorFlip(h);\n  if (h.left !== null && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst insertInNode = (h, value, compare, onInsertConflict) => {\n  var cmp;\n  if (h === null) {\n    return new Node(value);\n  }\n  //if h.left isnt null && h.left.isRed && h.right isnt null && h.right.isRed\n  //  colorFlip(h)\n  cmp = compare(value, h.value);\n  if (cmp === 0) {\n    h.value = onInsertConflict(h.value, value);\n  } else if (cmp < 0) {\n    h.left = insertInNode(h.left, value, compare, onInsertConflict);\n  } else {\n    h.right = insertInNode(h.right, value, compare, onInsertConflict);\n  }\n  if (h.right !== null && h.right.isRed && !(h.left !== null && h.left.isRed)) {\n    h = rotateLeft(h);\n  }\n  if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n  }\n  // Put this here -- I couldn't get the whole thing to work otherwise :(\n  if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst findMinNode = (h) => {\n  while (h.left !== null) {\n    h = h.left;\n  }\n  return h;\n};\n\nconst fixUp = (h) => {\n  // Fix right-leaning red nodes\n  if (h.right !== null && h.right.isRed) {\n    h = rotateLeft(h);\n  }\n  // Handle a 4-node that traverses down the left\n  if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n  }\n  // split 4-nodes\n  if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst removeMinNode = (h) => {\n  if (h.left === null) {\n    return null;\n  }\n  if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n    h = moveRedLeft(h);\n  }\n  h.left = removeMinNode(h.left);\n  return fixUp(h);\n};\n\nconst removeFromNode = (h, value, compare) => {\n  if (h === null) {\n    throw 'Value not in set';\n  }\n  if (h.value !== value && compare(value, h.value) < 0) {\n    if (h.left === null) {\n      throw 'Value not in set';\n    }\n    if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n      h = moveRedLeft(h);\n    }\n    h.left = removeFromNode(h.left, value, compare);\n  } else {\n    if (h.left !== null && h.left.isRed) {\n      h = rotateRight(h);\n    }\n    if (h.right === null) {\n      if (value === h.value) {\n        return null; // leaf node; LLRB assures no left value here\n      } else {\n        throw 'Value not in set';\n      }\n    }\n    if (!h.right.isRed && !(h.right.left !== null && h.right.left.isRed)) {\n      h = moveRedRight(h);\n    }\n    if (value === h.value) {\n      h.value = findMinNode(h.right).value;\n      h.right = removeMinNode(h.right);\n    } else {\n      h.right = removeFromNode(h.right, value, compare);\n    }\n  }\n  if (h !== null) {\n    h = fixUp(h);\n  }\n  return h;\n};\n\nclass RedBlackTreeStrategy extends AbstractBinaryTreeStrategy {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.root = null;\n  }\n\n  insert(value) {\n    this.root = insertInNode(this.root, value, this.comparator, this.onInsertConflict);\n    this.root.isRed = false; // always\n    return void 0;\n  }\n\n  remove(value) {\n    this.root = removeFromNode(this.root, value, this.comparator);\n    if (this.root !== null) {\n      this.root.isRed = false;\n    }\n    return void 0;\n  }\n\n};\n\nexport default RedBlackTreeStrategy;\n","const InsertConflictResolvers = {\n  OnInsertConflictThrow: (oldValue, newValue) => { throw new Error(\"Value already in set\") },\n  OnInsertConflictReplace: (oldValue, newValue) => newValue,\n  OnInsertConflictIgnore: (oldValue, newValue) => oldValue,\n};\nexport default InsertConflictResolvers;\n","import AbstractSortedSet from './SortedSet/AbstractSortedSet';\nimport ArrayStrategy from './SortedSet/ArrayStrategy';\nimport BinaryTreeStrategy from './SortedSet/BinaryTreeStrategy';\nimport RedBlackTreeStrategy from './SortedSet/RedBlackTreeStrategy';\nimport InsertConflictResolvers from './SortedSet/InsertConflictResolvers';\n\nclass SortedSet extends AbstractSortedSet {\n  constructor(options) {\n    options || (options = {});\n    options.strategy || (options.strategy = RedBlackTreeStrategy);\n    options.comparator || (options.comparator = function(a, b) {\n      return (a || 0) - (b || 0);\n    });\n    options.onInsertConflict || (options.onInsertConflict = InsertConflictResolvers.OnInsertConflictThrow);\n    super(options);\n  }\n};\n\nSortedSet.ArrayStrategy = ArrayStrategy;\nSortedSet.BinaryTreeStrategy = BinaryTreeStrategy;\nSortedSet.RedBlackTreeStrategy = RedBlackTreeStrategy;\n\nObject.assign(SortedSet, InsertConflictResolvers);\n\nexport default SortedSet;\n\n","\nclass AbstractSortedSet {\n  constructor(options) {\n    if ((options != null ? options.strategy : void 0) == null) {\n      throw 'Must pass options.strategy, a strategy';\n    }\n    if ((options != null ? options.comparator : void 0) == null) {\n      throw 'Must pass options.comparator, a comparator';\n    }\n    if ((options != null ? options.onInsertConflict : void 0) == null) {\n      throw 'Must pass options.onInsertConflict, a function';\n    }\n    this.priv = new options.strategy(options);\n    this.length = 0;\n  }\n\n  insert(value) {\n    this.priv.insert(value);\n    this.length += 1;\n    return this;\n  }\n\n  remove(value) {\n    this.priv.remove(value);\n    this.length -= 1;\n    return this;\n  }\n\n  clear() {\n    this.priv.clear();\n    this.length = 0;\n    return this;\n  }\n\n  contains(value) {\n    return this.priv.contains(value);\n  }\n\n  // Returns this set as an Array\n  toArray() {\n    return this.priv.toArray();\n  }\n\n  forEach(callback, thisArg) {\n    this.priv.forEachImpl(callback, this, thisArg);\n    return this;\n  }\n\n  map(callback, thisArg) {\n    var ret;\n    ret = [];\n    this.forEach(function(value, index, self) {\n      return ret.push(callback.call(thisArg, value, index, self));\n    });\n    return ret;\n  }\n\n  filter(callback, thisArg) {\n    var ret;\n    ret = [];\n    this.forEach(function(value, index, self) {\n      if (callback.call(thisArg, value, index, self)) {\n        return ret.push(value);\n      }\n    });\n    return ret;\n  }\n\n  every(callback, thisArg) {\n    var ret;\n    ret = true;\n    this.forEach(function(value, index, self) {\n      if (ret && !callback.call(thisArg, value, index, self)) {\n        return ret = false;\n      }\n    });\n    return ret;\n  }\n\n  some(callback, thisArg) {\n    var ret;\n    ret = false;\n    this.forEach(function(value, index, self) {\n      if (!ret && callback.call(thisArg, value, index, self)) {\n        return ret = true;\n      }\n    });\n    return ret;\n  }\n\n  // An iterator is similar to a C++ iterator: it points _before_ a value.\n\n  // So in this sorted set:\n\n  //   | 1 | 2 | 3 | 4 | 5 |\n  //   ^a      ^b          ^c\n\n  // `a` is a pointer to the beginning of the iterator. `a.value()` returns\n  // `3`. `a.previous()` returns `null`. `a.setValue()` works, if\n  // `options.allowSetValue` is true.\n\n  // `b` is a pointer to the value `3`. `a.previous()` and `a.next()` both do\n  // the obvious.\n\n  // `c` is a pointer to the `null` value. `c.previous()` works; `c.next()`\n  // returns null. `c.setValue()` throws an exception, even if\n  // `options.allowSetValue` is true.\n\n  // Iterators have `hasNext()` and `hasPrevious()` methods, too.\n\n  // Iterators are immutible. `iterator.next()` returns a new iterator.\n\n  // Iterators become invalid as soon as `insert()` or `remove()` is called.\n  findIterator(value) {\n    return this.priv.findIterator(value);\n  }\n\n  // Finds an iterator pointing to the lowest possible value.\n  beginIterator() {\n    return this.priv.beginIterator();\n  }\n\n  // Finds an iterator pointing to the `null` value.\n  endIterator() {\n    return this.priv.endIterator();\n  }\n\n};\n\nexport default AbstractSortedSet;\n\n"],"names":["Iterator","constructor","priv","index1","index","data","this","hasNext","length","hasPrevious","value","setValue","options","allowSetValue","next","previous","binarySearchForIndex","array","comparator","high","low","mid","descendAllTheWay","leftOrRight","node","parent","_iteratorParentNode","moveCursor","BinaryTreeIterator","tree1","node1","tree","root","find","cmp","nextNode","left","right","binaryTreeTraverse","callback","AbstractBinaryTree","toArray","ret","push","clear","forEachImpl","sortedSet","thisArg","i","call","contains","findIterator","beginIterator","endIterator","Node","value1","binaryTreeDelete","nodeAllTheWay","isRed","rotateLeft","h","x","rotateRight","colorFlip","moveRedLeft","insertInNode","compare","onInsertConflict","fixUp","removeMinNode","removeFromNode","moveRedRight","findMinNode","RedBlackTreeStrategy","AbstractBinaryTreeStrategy","insert","remove","InsertConflictResolvers","OnInsertConflictThrow","oldValue","newValue","Error","OnInsertConflictReplace","OnInsertConflictIgnore","SortedSet","strategy","forEach","map","self","filter","every","some","a","b","ArrayStrategy","splice","len","ref","BinaryTreeStrategy","Object","assign"],"mappings":"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"}