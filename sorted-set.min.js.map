{"version":3,"file":"sorted-set.min.js","sources":["src/SortedSet/AbstractSortedSet.js","src/SortedSet/ArrayStrategy.js","src/SortedSet/BinaryTreeIterator.js","src/SortedSet/AbstractBinaryTreeStrategy.js","src/SortedSet/BinaryTreeStrategy.js","src/SortedSet/RedBlackTreeStrategy.js","src/SortedSet/InsertConflictResolvers.js","src/SortedSet.js"],"sourcesContent":["\nclass AbstractSortedSet {\n  constructor(options) {\n    if ((options != null ? options.strategy : void 0) == null) {\n      throw 'Must pass options.strategy, a strategy';\n    }\n    if ((options != null ? options.comparator : void 0) == null) {\n      throw 'Must pass options.comparator, a comparator';\n    }\n    if ((options != null ? options.onInsertConflict : void 0) == null) {\n      throw 'Must pass options.onInsertConflict, a function';\n    }\n    this.priv = new options.strategy(options);\n    this.length = 0;\n  }\n\n  insert(value) {\n    this.priv.insert(value);\n    this.length += 1;\n    return this;\n  }\n\n  remove(value) {\n    this.priv.remove(value);\n    this.length -= 1;\n    return this;\n  }\n\n  clear() {\n    this.priv.clear();\n    this.length = 0;\n    return this;\n  }\n\n  contains(value) {\n    return this.priv.contains(value);\n  }\n\n  // Returns this set as an Array\n  toArray() {\n    return this.priv.toArray();\n  }\n\n  forEach(callback, thisArg) {\n    this.priv.forEachImpl(callback, this, thisArg);\n    return this;\n  }\n\n  map(callback, thisArg) {\n    const ret = [];\n    this.forEach(function(value, index, self) {\n      return ret.push(callback.call(thisArg, value, index, self));\n    });\n    return ret;\n  }\n\n  filter(callback, thisArg) {\n    const ret = [];\n    this.forEach(function(value, index, self) {\n      if (callback.call(thisArg, value, index, self)) {\n        return ret.push(value);\n      }\n    });\n    return ret;\n  }\n\n  every(callback, thisArg) {\n    let ret = true;\n    this.forEach(function(value, index, self) {\n      if (ret && !callback.call(thisArg, value, index, self)) {\n        ret = false;\n      }\n    });\n    return ret;\n  }\n\n  some(callback, thisArg) {\n    let ret = false;\n    this.forEach(function(value, index, self) {\n      if (!ret && callback.call(thisArg, value, index, self)) {\n        ret = true;\n      }\n    });\n    return ret;\n  }\n\n  // An iterator is similar to a C++ iterator: it points _before_ a value.\n\n  // So in this sorted set:\n\n  //   | 1 | 2 | 3 | 4 | 5 |\n  //   ^a      ^b          ^c\n\n  // `a` is a pointer to the beginning of the iterator. `a.value()` returns\n  // `3`. `a.previous()` returns `null`. `a.setValue()` works, if\n  // `options.allowSetValue` is true.\n\n  // `b` is a pointer to the value `3`. `a.previous()` and `a.next()` both do\n  // the obvious.\n\n  // `c` is a pointer to the `null` value. `c.previous()` works; `c.next()`\n  // returns null. `c.setValue()` throws an exception, even if\n  // `options.allowSetValue` is true.\n\n  // Iterators have `hasNext()` and `hasPrevious()` methods, too.\n\n  // Iterators are immutible. `iterator.next()` returns a new iterator.\n\n  // Iterators become invalid as soon as `insert()` or `remove()` is called.\n  findIterator(value) {\n    return this.priv.findIterator(value);\n  }\n\n  // Finds an iterator pointing to the lowest possible value.\n  beginIterator() {\n    return this.priv.beginIterator();\n  }\n\n  // Finds an iterator pointing to the `null` value.\n  endIterator() {\n    return this.priv.endIterator();\n  }\n\n};\n\nexport default AbstractSortedSet;\n\n","\nclass Iterator {\n  constructor(priv, index1) {\n    this.priv = priv;\n    this.index = index1;\n    this.data = this.priv.data;\n  }\n\n  hasNext() {\n    return this.index < this.data.length;\n  }\n\n  hasPrevious() {\n    return this.index > 0;\n  }\n\n  value() {\n    if (this.index < this.data.length) {\n      return this.data[this.index];\n    } else {\n      return null;\n    }\n  }\n\n  setValue(value) {\n    if (!this.priv.options.allowSetValue) {\n      throw 'Must set options.allowSetValue';\n    }\n    if (!this.hasNext()) {\n      throw 'Cannot set value at end of set';\n    }\n    return this.data[this.index] = value;\n  }\n\n  next() {\n    if (this.index >= this.data.length) {\n      return null;\n    } else {\n      return new Iterator(this.priv, this.index + 1);\n    }\n  }\n\n  previous() {\n    if (this.index <= 0) {\n      return null;\n    } else {\n      return new Iterator(this.priv, this.index - 1);\n    }\n  }\n\n};\n\nconst binarySearchForIndex = (array, value, comparator) => {\n  let low = 0;\n  let high = array.length;\n  while (low < high) {\n    const mid = (low + high) >>> 1;\n    if (comparator(array[mid], value) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\n\nclass ArrayStrategy {\n  constructor(options) {\n    this.options = options;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.comparator = this.options.comparator;\n    this.data = [];\n  }\n\n  toArray() {\n    return this.data;\n  }\n\n  insert(value) {\n    const index = binarySearchForIndex(this.data, value, this.comparator);\n    if (this.data[index] !== void 0 && this.comparator(this.data[index], value) === 0) {\n      return this.data.splice(index, 1, this.onInsertConflict(this.data[index], value));\n    } else {\n      return this.data.splice(index, 0, value);\n    }\n  }\n\n  remove(value) {\n    const index = binarySearchForIndex(this.data, value, this.comparator);\n    if (this.comparator(this.data[index], value) !== 0) {\n      throw 'Value not in set';\n    }\n    return this.data.splice(index, 1);\n  }\n\n  clear() {\n    return this.data.length = 0;\n  }\n\n  contains(value) {\n    const index = binarySearchForIndex(this.data, value, this.comparator);\n    return this.index !== this.data.length && this.comparator(this.data[index], value) === 0;\n  }\n\n  forEachImpl(callback, sortedSet, thisArg) {\n    const data = this.data;\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n      callback.call(thisArg, data[i], i, sortedSet);\n    }\n  }\n\n  findIterator(value) {\n    const index = binarySearchForIndex(this.data, value, this.comparator);\n    return new Iterator(this, index);\n  }\n\n  beginIterator() {\n    return new Iterator(this, 0);\n  }\n\n  endIterator() {\n    return new Iterator(this, this.data.length);\n  }\n};\n\nexport default ArrayStrategy;\n","const descendAllTheWay = (leftOrRight, node) => {\n  // Assumes node._iteratorParentNode is set\n  while (node[leftOrRight] !== null) {\n    const parent = node;\n    node = node[leftOrRight];\n    node._iteratorParentNode = parent;\n  }\n  return node;\n};\n\nconst moveCursor = (leftOrRight, node) => {\n  let parent, rightOrLeft;\n  if (node[leftOrRight] !== null) {\n    parent = node;\n    node = node[leftOrRight];\n    node._iteratorParentNode = parent;\n    rightOrLeft = leftOrRight === 'left' ? 'right' : 'left';\n    node = descendAllTheWay(rightOrLeft, node);\n  } else {\n    while ((parent = node._iteratorParentNode) !== null && parent[leftOrRight] === node) {\n      node = parent;\n    }\n    node = parent; // either null or the correct-direction parent\n  }\n  return node;\n};\n\n// The BinaryTreeIterator actually writes to the tree: it maintains a\n// \"_iteratorParentNode\" variable on each node. Please ignore this.\nclass BinaryTreeIterator {\n  constructor(tree1, node1) {\n    this.tree = tree1;\n    this.node = node1;\n  }\n\n  next() {\n    if (this.node === null) {\n      return null;\n    } else {\n      const node = moveCursor('right', this.node);\n      return new BinaryTreeIterator(this.tree, node);\n    }\n  }\n\n  previous() {\n    if (this.node === null) {\n      if (this.tree.root === null) {\n        return null;\n      } else {\n        this.tree.root._iteratorParentNode = null;\n        const node = descendAllTheWay('right', this.tree.root);\n        return new BinaryTreeIterator(this.tree, node);\n      }\n    } else {\n      const node = moveCursor('left', this.node);\n      if (node === null) {\n        return null;\n      } else {\n        return new BinaryTreeIterator(this.tree, node);\n      }\n    }\n  }\n\n  hasNext() {\n    return this.node !== null;\n  }\n\n  hasPrevious() {\n    return this.previous() !== null;\n  }\n\n  value() {\n    if (this.node === null) {\n      return null;\n    } else {\n      return this.node.value;\n    }\n  }\n\n  setValue(value) {\n    if (!this.tree.options.allowSetValue) {\n      throw 'Must set options.allowSetValue';\n    }\n    if (!this.hasNext()) {\n      throw 'Cannot set value at end of set';\n    }\n    return this.node.value = value;\n  }\n\n};\n\nBinaryTreeIterator.find = function(tree, value, comparator) {\n  const root = tree.root;\n  if (root != null) {\n    root._iteratorParentNode = null;\n  }\n  let node = root;\n  let nextNode = null; // For finding an in-between node\n  while (node !== null) {\n    const cmp = comparator(value, node.value);\n    if (cmp === 0) {\n      break;\n    } else if (cmp < 0) {\n      if (node.left === null) {\n        break;\n      }\n      nextNode = node; // If we descend all right after this until there are\n      // no more right nodes, we want to return an\n      // \"in-between\" iterator ... pointing here.\n      node.left._iteratorParentNode = node;\n      node = node.left;\n    } else {\n      if (node.right !== null) {\n        node.right._iteratorParentNode = node;\n        node = node.right;\n      } else {\n        node = nextNode;\n        break;\n      }\n    }\n  }\n  return new BinaryTreeIterator(tree, node);\n};\n\nBinaryTreeIterator.left = (tree) => {\n  if (tree.root === null) {\n    return new BinaryTreeIterator(tree, null);\n  } else {\n    tree.root._iteratorParentNode = null;\n    const node = descendAllTheWay('left', tree.root);\n    return new BinaryTreeIterator(tree, node);\n  }\n};\n\nBinaryTreeIterator.right = (tree) => {\n  return new BinaryTreeIterator(tree, null);\n};\n\nexport default BinaryTreeIterator;\n","\nimport BinaryTreeIterator from './BinaryTreeIterator';\n\nconst binaryTreeTraverse = (node, callback) => {\n  if (node !== null) {\n    binaryTreeTraverse(node.left, callback);\n    callback(node.value);\n    binaryTreeTraverse(node.right, callback);\n  }\n};\n\n// An AbstractBinaryTree has a @root. @root is null or an object with\n// `.left`, `.right` and `.value` properties.\nclass AbstractBinaryTree {\n  toArray() {\n    const ret = [];\n    binaryTreeTraverse(this.root, function(value) {\n      return ret.push(value);\n    });\n    return ret;\n  }\n\n  clear() {\n    return this.root = null;\n  }\n\n  forEachImpl(callback, sortedSet, thisArg) {\n    let i = 0;\n    binaryTreeTraverse(this.root, function(value) {\n      callback.call(thisArg, value, i, sortedSet);\n      i += 1;\n    });\n  }\n\n  contains(value) {\n    const comparator = this.comparator;\n    let node = this.root;\n    while (node !== null) {\n      const cmp = comparator(value, node.value);\n      if (cmp === 0) {\n        break;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n    return node !== null && comparator(node.value, value) === 0;\n  }\n\n  findIterator(value) {\n    return BinaryTreeIterator.find(this, value, this.comparator);\n  }\n\n  beginIterator() {\n    return BinaryTreeIterator.left(this);\n  }\n\n  endIterator() {\n    return BinaryTreeIterator.right(this);\n  }\n\n};\n\nexport default AbstractBinaryTree;\n\n","import AbstractBinaryTreeStrategy from './AbstractBinaryTreeStrategy';\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n};\n\nconst nodeAllTheWay = (node, leftOrRight) => {\n  while (node[leftOrRight] !== null) {\n    node = node[leftOrRight];\n  }\n  return node;\n};\n\n// Returns the subtree, minus value\nconst binaryTreeDelete = (node, value, comparator) => {\n  if (node === null) {\n    throw 'Value not in set';\n  }\n  const cmp = comparator(value, node.value);\n  if (cmp < 0) {\n    node.left = binaryTreeDelete(node.left, value, comparator);\n  } else if (cmp > 0) {\n    node.right = binaryTreeDelete(node.right, value, comparator); // This is the value we want to remove\n  } else {\n    if (node.left === null && node.right === null) {\n      node = null;\n    } else if (node.right === null) {\n      node = node.left;\n    } else if (node.left === null) {\n      node = node.right;\n    } else {\n      const nextNode = nodeAllTheWay(node.right, 'left');\n      node.value = nextNode.value;\n      node.right = binaryTreeDelete(node.right, nextNode.value, comparator);\n    }\n  }\n  return node;\n};\n\nclass BinaryTreeStrategy extends AbstractBinaryTreeStrategy {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.root = null;\n  }\n\n  insert(value) {\n    const compare = this.comparator;\n    if (this.root !== null) {\n      let parent = this.root;\n      let leftOrRight = null;\n      while (true) {\n        const cmp = compare(value, parent.value);\n        if (cmp === 0) {\n          parent.value = this.onInsertConflict(parent.value, value);\n          return;\n        } else {\n          leftOrRight = cmp < 0 ? 'left' : 'right';\n          if (parent[leftOrRight] === null) {\n            break;\n          }\n          parent = parent[leftOrRight];\n        }\n      }\n      return parent[leftOrRight] = new Node(value);\n    } else {\n      return this.root = new Node(value);\n    }\n  }\n\n  remove(value) {\n    return this.root = binaryTreeDelete(this.root, value, this.comparator);\n  }\n\n};\n\nexport default BinaryTreeStrategy;\n","\nimport AbstractBinaryTreeStrategy from './AbstractBinaryTreeStrategy';\n\n// An implementation of Left-Leaning Red-Black trees.\n\n// It's copied from http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf.\n// It's practically a copy-paste job, minus the semicolons. missing bits were\n// filled in with hints from\n// http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\n\n// Here are some differences:\n// * This isn't a map structure: it's just a tree. There are no keys: the\n//   comparator applies to the values.\n// * We use the passed comparator.\nclass Node {\n  constructor(value1) {\n    this.value = value1;\n    this.left = null;\n    this.right = null;\n    this.isRed = true; // null nodes -- leaves -- are black\n  }\n\n};\n\nconst rotateLeft = (h) => {\n  const x = h.right;\n  h.right = x.left;\n  x.left = h;\n  x.isRed = h.isRed;\n  h.isRed = true;\n  return x;\n};\n\nconst rotateRight = (h) => {\n  const x = h.left;\n  h.left = x.right;\n  x.right = h;\n  x.isRed = h.isRed;\n  h.isRed = true;\n  return x;\n};\n\nconst colorFlip = (h) => {\n  h.isRed = !h.isRed;\n  h.left.isRed = !h.left.isRed;\n  h.right.isRed = !h.right.isRed;\n};\n\nconst moveRedLeft = (h) => {\n  //throw 'Preconditions failed' if !(!h.left.isRed && !h.left.left?.isRed)\n  colorFlip(h);\n  if (h.right !== null && h.right.left !== null && h.right.left.isRed) {\n    h.right = rotateRight(h.right);\n    h = rotateLeft(h);\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst moveRedRight = (h) => {\n  //throw 'Preconditions failed' if !(!h.right.isRed && !h.right.left?.isRed)\n  colorFlip(h);\n  if (h.left !== null && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst insertInNode = (h, value, compare, onInsertConflict) => {\n  if (h === null) {\n    return new Node(value);\n  }\n  //if h.left isnt null && h.left.isRed && h.right isnt null && h.right.isRed\n  //  colorFlip(h)\n  const cmp = compare(value, h.value);\n  if (cmp === 0) {\n    h.value = onInsertConflict(h.value, value);\n  } else if (cmp < 0) {\n    h.left = insertInNode(h.left, value, compare, onInsertConflict);\n  } else {\n    h.right = insertInNode(h.right, value, compare, onInsertConflict);\n  }\n  if (h.right !== null && h.right.isRed && !(h.left !== null && h.left.isRed)) {\n    h = rotateLeft(h);\n  }\n  if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n  }\n  // Put this here -- I couldn't get the whole thing to work otherwise :(\n  if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst findMinNode = (h) => {\n  while (h.left !== null) {\n    h = h.left;\n  }\n  return h;\n};\n\nconst fixUp = (h) => {\n  // Fix right-leaning red nodes\n  if (h.right !== null && h.right.isRed) {\n    h = rotateLeft(h);\n  }\n  // Handle a 4-node that traverses down the left\n  if (h.left !== null && h.left.isRed && h.left.left !== null && h.left.left.isRed) {\n    h = rotateRight(h);\n  }\n  // split 4-nodes\n  if (h.left !== null && h.left.isRed && h.right !== null && h.right.isRed) {\n    colorFlip(h);\n  }\n  return h;\n};\n\nconst removeMinNode = (h) => {\n  if (h.left === null) {\n    return null;\n  }\n  if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n    h = moveRedLeft(h);\n  }\n  h.left = removeMinNode(h.left);\n  return fixUp(h);\n};\n\nconst removeFromNode = (h, value, compare) => {\n  if (h === null) {\n    throw 'Value not in set';\n  }\n  if (compare(value, h.value) < 0) {\n    if (h.left === null) {\n      throw 'Value not in set';\n    }\n    if (!h.left.isRed && !(h.left.left !== null && h.left.left.isRed)) {\n      h = moveRedLeft(h);\n    }\n    h.left = removeFromNode(h.left, value, compare);\n  } else {\n    if (h.left !== null && h.left.isRed) {\n      h = rotateRight(h);\n    }\n    if (h.right === null) {\n      if (compare(value, h.value) === 0) {\n        return null; // leaf node; LLRB assures no left value here\n      } else {\n        throw 'Value not in set';\n      }\n    }\n    if (!h.right.isRed && !(h.right.left !== null && h.right.left.isRed)) {\n      h = moveRedRight(h);\n    }\n    if (compare(value, h.value) === 0) {\n      h.value = findMinNode(h.right).value;\n      h.right = removeMinNode(h.right);\n    } else {\n      h.right = removeFromNode(h.right, value, compare);\n    }\n  }\n  if (h !== null) {\n    h = fixUp(h);\n  }\n  return h;\n};\n\nclass RedBlackTreeStrategy extends AbstractBinaryTreeStrategy {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.onInsertConflict = this.options.onInsertConflict;\n    this.root = null;\n  }\n\n  insert(value) {\n    this.root = insertInNode(this.root, value, this.comparator, this.onInsertConflict);\n    this.root.isRed = false; // always\n  }\n\n  remove(value) {\n    this.root = removeFromNode(this.root, value, this.comparator);\n    if (this.root !== null) {\n      this.root.isRed = false;\n    }\n  }\n\n};\n\nexport default RedBlackTreeStrategy;\n","const InsertConflictResolvers = {\n  OnInsertConflictThrow: (oldValue, newValue) => { throw new Error(\"Value already in set\") },\n  OnInsertConflictReplace: (oldValue, newValue) => newValue,\n  OnInsertConflictIgnore: (oldValue, newValue) => oldValue,\n};\nexport default InsertConflictResolvers;\n","import AbstractSortedSet from './SortedSet/AbstractSortedSet';\nimport ArrayStrategy from './SortedSet/ArrayStrategy';\nimport BinaryTreeStrategy from './SortedSet/BinaryTreeStrategy';\nimport RedBlackTreeStrategy from './SortedSet/RedBlackTreeStrategy';\nimport InsertConflictResolvers from './SortedSet/InsertConflictResolvers';\n\nclass SortedSet extends AbstractSortedSet {\n  constructor(options) {\n    options || (options = {});\n    options.strategy || (options.strategy = RedBlackTreeStrategy);\n    options.comparator || (options.comparator = function(a, b) {\n      return (a || 0) - (b || 0);\n    });\n    options.onInsertConflict || (options.onInsertConflict = InsertConflictResolvers.OnInsertConflictThrow);\n    super(options);\n  }\n};\n\nSortedSet.ArrayStrategy = ArrayStrategy;\nSortedSet.BinaryTreeStrategy = BinaryTreeStrategy;\nSortedSet.RedBlackTreeStrategy = RedBlackTreeStrategy;\n\nObject.assign(SortedSet, InsertConflictResolvers);\n\nexport default SortedSet;\n\n"],"names":["AbstractSortedSet","constructor","options","strategy","comparator","onInsertConflict","this","priv","length","insert","value","remove","clear","contains","toArray","forEach","callback","thisArg","forEachImpl","map","ret","index","self","push","call","filter","every","some","findIterator","beginIterator","endIterator","Iterator","index1","data","hasNext","hasPrevious","setValue","allowSetValue","next","previous","binarySearchForIndex","array","low","high","mid","descendAllTheWay","leftOrRight","node","parent","_iteratorParentNode","moveCursor","rightOrLeft","BinaryTreeIterator","tree1","node1","tree","root","find","nextNode","cmp","left","right","binaryTreeTraverse","AbstractBinaryTree","sortedSet","i","Node$1","binaryTreeDelete","nodeAllTheWay","Node","value1","isRed","rotateLeft","h","x","rotateRight","colorFlip","moveRedLeft","insertInNode","compare","fixUp","removeMinNode","removeFromNode","moveRedRight","findMinNode","RedBlackTreeStrategy","AbstractBinaryTreeStrategy","super","InsertConflictResolvers","OnInsertConflictThrow","oldValue","newValue","Error","OnInsertConflictReplace","OnInsertConflictIgnore","SortedSet","a","b","ArrayStrategy","splice","len","BinaryTreeStrategy","Object","assign"],"mappings":"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"}